{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "3db46b46",
   "metadata": {},
   "source": [
    "# Functions tutorial\n",
    "\n",
    "In astromodels functions can be used as spectral shapes for sources, or to describe time-dependence, phase-dependence, or links among parameters.\n",
    "\n",
    "To get the list of available functions just do:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "fe592518",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:26.343950Z",
     "iopub.status.busy": "2024-02-07T19:30:26.343407Z",
     "iopub.status.idle": "2024-02-07T19:30:30.851256Z",
     "shell.execute_reply": "2024-02-07T19:30:30.848806Z"
    }
   },
   "outputs": [],
   "source": [
    "%%capture\n",
    "from astromodels import *"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2d7dd222",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:30.860989Z",
     "iopub.status.busy": "2024-02-07T19:30:30.859206Z",
     "iopub.status.idle": "2024-02-07T19:30:30.878982Z",
     "shell.execute_reply": "2024-02-07T19:30:30.876365Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div><table id=\"table4516733424\">\n",
       "<thead><tr><th>name</th><th>Description</th></tr></thead>\n",
       "<tr><td>Asymm_Gaussian_on_sphere</td><td>A bidimensional Gaussian function on a sphere (in spherical coordinates)\\nsee https://en.wikipedia.org/wiki/Gaussian_function#Two-dimensional_Gaussian_function</td></tr>\n",
       "<tr><td>Band</td><td>Band model from Band et al., 1993, parametrized with the peak energy</td></tr>\n",
       "<tr><td>Band_Calderone</td><td>The Band model from Band et al. 1993, implemented however in a way which reduces the covariances between the parameters (Calderone et al., MNRAS, 448, 403C, 2015)</td></tr>\n",
       "<tr><td>Band_grbm</td><td>Band model from Band et al., 1993, parametrized with the cutoff energy</td></tr>\n",
       "<tr><td>Beta</td><td>A beta distribution function</td></tr>\n",
       "<tr><td>Blackbody</td><td>A blackbody function</td></tr>\n",
       "<tr><td>Broken_powerlaw</td><td>A broken power law function</td></tr>\n",
       "<tr><td>Cauchy</td><td>The Cauchy distribution</td></tr>\n",
       "<tr><td>Constant</td><td>Return k</td></tr>\n",
       "<tr><td>Continuous_injection_diffusion</td><td>Positron and electrons diffusing away from the accelerator</td></tr>\n",
       "<tr><td>...</td><td>...</td></tr>\n",
       "<tr><td>SpatialTemplate_2D</td><td>User input Spatial Template.  Expected to be normalized to 1/sr</td></tr>\n",
       "<tr><td>StepFunction</td><td>A function which is constant on the interval lower_bound - upper_bound and 0 outside the interval. The extremes of the interval are counted as part of the interval.</td></tr>\n",
       "<tr><td>StepFunctionUpper</td><td>A function which is constant on the interval lower_bound - upper_bound and 0 outside the interval. The upper interval is open.</td></tr>\n",
       "<tr><td>Super_cutoff_powerlaw</td><td>A power law with a super-exponential cutoff</td></tr>\n",
       "<tr><td>TbAbs</td><td>Photometric absorption (Tbabs implementation), f(E) = exp(- NH * sigma(E)) contributed by Dominique Eckert</td></tr>\n",
       "<tr><td>TemplateModel</td><td>A template model</td></tr>\n",
       "<tr><td>Truncated_gaussian</td><td>A  truncated Gaussian function defined on the interval between the lower_bound (a) and upper_bound (b)</td></tr>\n",
       "<tr><td>Uniform_prior</td><td>A function which is constant on the interval lower_bound - upper_bound and 0 outside the interval. The extremes of the interval are counted as part of the interval.</td></tr>\n",
       "<tr><td>WAbs</td><td>Photometric absorption (Wabs implementation), f(E) = exp(- NH * sigma(E)) contributed by Dominique Eckert</td></tr>\n",
       "<tr><td>ZDust</td><td>Extinction by dust grains from Pei (1992), suitable for IR, optical and UV energy bands, including the full energy ranges of the Swift UVOT and XMM-Newton OM detectors. Three models are included which characterize the extinction curves of (1) the Milky Way, (2) the LMC and (3) the SMC. The models can be modified by redshift and can therefore be applied to extragalactic sources. The transmission is set to unity shortward of 912 Angstroms in the rest frame of the dust. This is incorrect physically but does allow the model to be used in combination with an X-ray photoelectric absorption model such as phabs. Parameter 1 (method) describes which extinction curve (MW, LMC or SMC) will be constructed and should never be allowed to float during a fit. The extinction at V, A(V) = E(B-V) x Rv. Rv should typically remain frozen for a fit. Standard values for Rv are MW = 3.08, LMC = 3.16 and SMC = 2.93 (from table 2 of Pei 1992), although these may not be applicable to more distant dusty sources.</td></tr>\n",
       "<tr><td>_ComplexTestFunction</td><td>A useless function to be used during automatic tests</td></tr>\n",
       "</table></div>"
      ],
      "text/plain": [
       "             name              ...\n",
       "------------------------------ ...\n",
       "      Asymm_Gaussian_on_sphere ...\n",
       "                          Band ...\n",
       "                Band_Calderone ...\n",
       "                     Band_grbm ...\n",
       "                          Beta ...\n",
       "                     Blackbody ...\n",
       "               Broken_powerlaw ...\n",
       "                        Cauchy ...\n",
       "                      Constant ...\n",
       "Continuous_injection_diffusion ...\n",
       "                           ... ...\n",
       "            SpatialTemplate_2D ...\n",
       "                  StepFunction ...\n",
       "             StepFunctionUpper ...\n",
       "         Super_cutoff_powerlaw ...\n",
       "                         TbAbs ...\n",
       "                 TemplateModel ...\n",
       "            Truncated_gaussian ...\n",
       "                 Uniform_prior ...\n",
       "                          WAbs ...\n",
       "                         ZDust ...\n",
       "          _ComplexTestFunction ..."
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list_functions()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d6b8a5e",
   "metadata": {},
   "source": [
    "If you need more info about a function, you can obtain it by using:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "2b1239fa",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:30.904834Z",
     "iopub.status.busy": "2024-02-07T19:30:30.903860Z",
     "iopub.status.idle": "2024-02-07T19:30:30.925244Z",
     "shell.execute_reply": "2024-02-07T19:30:30.921340Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<ul>\n",
       "\n",
       "<li>description: A Gaussian function</li>\n",
       "\n",
       "<li>formula: $ K \\frac{1}{\\sigma \\sqrt{2 \\pi}}\\exp{\\frac{(x-\\mu)^2}{2~(\\sigma)^2}} $</li>\n",
       "\n",
       "<li>default parameters: \n",
       "<ul>\n",
       "\n",
       "<li>F: \n",
       "<ul>\n",
       "\n",
       "<li>value: 1.0</li>\n",
       "\n",
       "<li>desc: Integral between -inf and +inf. Fix this to 1 to obtain a Normal distribution</li>\n",
       "\n",
       "<li>min_value: None</li>\n",
       "\n",
       "<li>max_value: None</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>mu: \n",
       "<ul>\n",
       "\n",
       "<li>value: 0.0</li>\n",
       "\n",
       "<li>desc: Central value</li>\n",
       "\n",
       "<li>min_value: None</li>\n",
       "\n",
       "<li>max_value: None</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>sigma: \n",
       "<ul>\n",
       "\n",
       "<li>value: 1.0</li>\n",
       "\n",
       "<li>desc: standard deviation</li>\n",
       "\n",
       "<li>min_value: 1e-12</li>\n",
       "\n",
       "<li>max_value: None</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "Gaussian.info()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "51353f66",
   "metadata": {},
   "source": [
    "Note that you don’t need to create an instance in order to call the info() method."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5eb6abbe",
   "metadata": {},
   "source": [
    "## Creating functions\n",
    "\n",
    "Functions can be created in two different ways. We can create an instance with the default values for the parameters like this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "000697be",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:30.938448Z",
     "iopub.status.busy": "2024-02-07T19:30:30.937935Z",
     "iopub.status.idle": "2024-02-07T19:30:30.946896Z",
     "shell.execute_reply": "2024-02-07T19:30:30.944465Z"
    }
   },
   "outputs": [],
   "source": [
    "powerlaw_instance = Powerlaw()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "630c2df1",
   "metadata": {},
   "source": [
    "or we can specify on construction specific values for the parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "d81ed8ad",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:30.955523Z",
     "iopub.status.busy": "2024-02-07T19:30:30.954983Z",
     "iopub.status.idle": "2024-02-07T19:30:30.963703Z",
     "shell.execute_reply": "2024-02-07T19:30:30.962126Z"
    }
   },
   "outputs": [],
   "source": [
    "powerlaw_instance = Powerlaw(K=0.01, index=-2.2)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf2bb82f",
   "metadata": {},
   "source": [
    "If you don’t remember the names of the parameters just call the .info() method as in powerlaw.info() as demonstrated above."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ce9a5775",
   "metadata": {},
   "source": [
    "## Getting information about an instance\n",
    "\n",
    "Using the ```.display()``` method we get a representation of the instance which exploits the features of the environment we are using. If we are running inside a IPython notebook, a rich representation with the formula of the function will be displayed (if available). Otherwise, in a normal terminal, the latex formula will not be rendered:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "889cede1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:30.973921Z",
     "iopub.status.busy": "2024-02-07T19:30:30.972638Z",
     "iopub.status.idle": "2024-02-07T19:30:30.991597Z",
     "shell.execute_reply": "2024-02-07T19:30:30.988393Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<ul>\n",
       "\n",
       "<li>description: A simple power-law</li>\n",
       "\n",
       "<li>formula: $ K~\\frac{x}{piv}^{index} $</li>\n",
       "\n",
       "<li>parameters: \n",
       "<ul>\n",
       "\n",
       "<li>K: \n",
       "<ul>\n",
       "\n",
       "<li>value: 0.01</li>\n",
       "\n",
       "<li>desc: Normalization (differential flux at the pivot value)</li>\n",
       "\n",
       "<li>min_value: 1e-30</li>\n",
       "\n",
       "<li>max_value: 1000.0</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: True</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>piv: \n",
       "<ul>\n",
       "\n",
       "<li>value: 1.0</li>\n",
       "\n",
       "<li>desc: Pivot value</li>\n",
       "\n",
       "<li>min_value: None</li>\n",
       "\n",
       "<li>max_value: None</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: False</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>index: \n",
       "<ul>\n",
       "\n",
       "<li>value: -2.2</li>\n",
       "\n",
       "<li>desc: Photon index</li>\n",
       "\n",
       "<li>min_value: -10.0</li>\n",
       "\n",
       "<li>max_value: 10.0</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.20099999999999998</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n"
      ],
      "text/plain": [
       "  * description: A simple power-law\n",
       "  * formula: $ K~\\frac{x}{piv}^{index} $\n",
       "  * parameters:\n",
       "    * K:\n",
       "      * value: 0.01\n",
       "      * desc: Normalization (differential flux at the pivot value)\n",
       "      * min_value: 1.0e-30\n",
       "      * max_value: 1000.0\n",
       "      * unit: ''\n",
       "      * is_normalization: true\n",
       "      * delta: 0.1\n",
       "      * free: true\n",
       "    * piv:\n",
       "      * value: 1.0\n",
       "      * desc: Pivot value\n",
       "      * min_value: null\n",
       "      * max_value: null\n",
       "      * unit: ''\n",
       "      * is_normalization: false\n",
       "      * delta: 0.1\n",
       "      * free: false\n",
       "    * index:\n",
       "      * value: -2.2\n",
       "      * desc: Photon index\n",
       "      * min_value: -10.0\n",
       "      * max_value: 10.0\n",
       "      * unit: ''\n",
       "      * is_normalization: false\n",
       "      * delta: 0.20099999999999998\n",
       "      * free: true"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "powerlaw_instance.display()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9fa8e1a8",
   "metadata": {},
   "source": [
    "It is also possible to get the text-only representation by simply printing the object like this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "c406aecb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.000948Z",
     "iopub.status.busy": "2024-02-07T19:30:31.000522Z",
     "iopub.status.idle": "2024-02-07T19:30:31.014557Z",
     "shell.execute_reply": "2024-02-07T19:30:31.012536Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  * description: A simple power-law\n",
      "  * formula: $ K~\\frac{x}{piv}^{index} $\n",
      "  * parameters:\n",
      "    * K:\n",
      "      * value: 0.01\n",
      "      * desc: Normalization (differential flux at the pivot value)\n",
      "      * min_value: 1.0e-30\n",
      "      * max_value: 1000.0\n",
      "      * unit: ''\n",
      "      * is_normalization: true\n",
      "      * delta: 0.1\n",
      "      * free: true\n",
      "    * piv:\n",
      "      * value: 1.0\n",
      "      * desc: Pivot value\n",
      "      * min_value: null\n",
      "      * max_value: null\n",
      "      * unit: ''\n",
      "      * is_normalization: false\n",
      "      * delta: 0.1\n",
      "      * free: false\n",
      "    * index:\n",
      "      * value: -2.2\n",
      "      * desc: Photon index\n",
      "      * min_value: -10.0\n",
      "      * max_value: 10.0\n",
      "      * unit: ''\n",
      "      * is_normalization: false\n",
      "      * delta: 0.20099999999999998\n",
      "      * free: true\n",
      "\n"
     ]
    }
   ],
   "source": [
    "print(powerlaw_instance)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8e7422fd",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Note:** the ```.display()``` method of an instance displays the current values of the parameters, while the .info() method demonstrated above (for which you don’t need an instance) displays the default values of the parameters.\n",
    "\n",
    "</div>\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "27cc04ed",
   "metadata": {},
   "source": [
    "## Modifying parameters\n",
    "\n",
    "Modifying a parameter of a function is easy:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "457d9843",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.024627Z",
     "iopub.status.busy": "2024-02-07T19:30:31.024120Z",
     "iopub.status.idle": "2024-02-07T19:30:31.049810Z",
     "shell.execute_reply": "2024-02-07T19:30:31.046744Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"color: #00ff00; text-decoration-color: #00ff00\">19:30:31 </span><span style=\"color: #af5fd7; text-decoration-color: #af5fd7\">WARNING </span> <span style=\"color: #c6c6c6; text-decoration-color: #c6c6c6; font-weight: bold\"> We have set the min_value of Powerlaw.K to </span><span style=\"color: #c0c0c0; text-decoration-color: #c0c0c0; font-weight: bold\">1e-99</span><span style=\"color: #c6c6c6; text-decoration-color: #c6c6c6; font-weight: bold\"> because there was a postive    </span><a href=\"file:///Users/runner/work/astromodels/astromodels/astromodels/core/parameter.py\" target=\"_blank\"><span style=\"color: #7f7f7f; text-decoration-color: #7f7f7f\">parameter.py</span></a><span style=\"color: #7f7f7f; text-decoration-color: #7f7f7f\">:</span><a href=\"file:///Users/runner/work/astromodels/astromodels/astromodels/core/parameter.py#704\" target=\"_blank\"><span style=\"color: #7f7f7f; text-decoration-color: #7f7f7f\">704</span></a>\n",
       "<span style=\"color: #00ff00; text-decoration-color: #00ff00\">         </span>         <span style=\"color: #c6c6c6; text-decoration-color: #c6c6c6; font-weight: bold\">transform                                                                        </span><span style=\"color: #7f7f7f; text-decoration-color: #7f7f7f\">                </span>\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[38;5;46m19:30:31\u001b[0m\u001b[38;5;46m \u001b[0m\u001b[38;5;134mWARNING \u001b[0m \u001b[1;38;5;251m We have set the min_value of Powerlaw.K to \u001b[0m\u001b[1;37m1e-99\u001b[0m\u001b[1;38;5;251m because there was a postive   \u001b[0m\u001b[1;38;5;251m \u001b[0m\u001b]8;id=234332;file:///Users/runner/work/astromodels/astromodels/astromodels/core/parameter.py\u001b\\\u001b[2mparameter.py\u001b[0m\u001b]8;;\u001b\\\u001b[2m:\u001b[0m\u001b]8;id=139437;file:///Users/runner/work/astromodels/astromodels/astromodels/core/parameter.py#704\u001b\\\u001b[2m704\u001b[0m\u001b]8;;\u001b\\\n",
       "\u001b[38;5;46m         \u001b[0m         \u001b[1;38;5;251mtransform                                                                       \u001b[0m\u001b[1;38;5;251m \u001b[0m\u001b[2m                \u001b[0m\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "Parameter K = 1.2 []\n",
       "(min_value = 0.5, max_value = 15.0, delta = 0.25, free = True)"
      ],
      "text/plain": [
       "Parameter K = 1.2 []\n",
       "(min_value = 0.5, max_value = 15.0, delta = 0.25, free = True)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Modify current value\n",
    "\n",
    "powerlaw_instance.K = 1.2\n",
    "\n",
    "# Modify minimum\n",
    "powerlaw_instance.K.min_value = 0.5\n",
    "\n",
    "# Modify maximum\n",
    "powerlaw_instance.K.max_value = 15\n",
    "\n",
    "# We can also modify minimum and maximum at the same time\n",
    "powerlaw_instance.K.bounds = (0.5, 15)\n",
    "\n",
    "# Modifying the delta for the parameter\n",
    "# (which can be used by downstream software for fitting, for example)\n",
    "powerlaw_instance.K.delta = 0.25\n",
    "\n",
    "# Fix the parameter\n",
    "powerlaw_instance.K.fix = True\n",
    "\n",
    "# or equivalently\n",
    "powerlaw_instance.K.free = False\n",
    "\n",
    "# Free it again\n",
    "powerlaw_instance.K.fix = False\n",
    "\n",
    "# or equivalently\n",
    "powerlaw_instance.K.free = True\n",
    "\n",
    "# We can verify what we just did by printing again the whole function as shown above,\n",
    "# or simply printing the parameter:\n",
    "powerlaw_instance.K.display()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd5b7ec0",
   "metadata": {},
   "source": [
    "## Using physical units\n",
    "\n",
    "Astromodels uses the facility defined in astropy.units to make easier to convert between units during interactive analysis, when assigning to parameters. In order for functions to be aware of their units, they must be part of a ```Source``. Let's create one:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "013d8cab",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.059255Z",
     "iopub.status.busy": "2024-02-07T19:30:31.058593Z",
     "iopub.status.idle": "2024-02-07T19:30:31.070170Z",
     "shell.execute_reply": "2024-02-07T19:30:31.068346Z"
    }
   },
   "outputs": [],
   "source": [
    "powerlaw_instance = Powerlaw()\n",
    "\n",
    "point_source = PointSource(\"my_point_source\",ra=0,dec=0, spectral_shape=powerlaw_instance)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b27faf76",
   "metadata": {},
   "source": [
    "Now we can see the units"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "7203bb6c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.080189Z",
     "iopub.status.busy": "2024-02-07T19:30:31.079251Z",
     "iopub.status.idle": "2024-02-07T19:30:31.094348Z",
     "shell.execute_reply": "2024-02-07T19:30:31.091810Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<ul>\n",
       "\n",
       "<li>description: A simple power-law</li>\n",
       "\n",
       "<li>formula: $ K~\\frac{x}{piv}^{index} $</li>\n",
       "\n",
       "<li>parameters: \n",
       "<ul>\n",
       "\n",
       "<li>K: \n",
       "<ul>\n",
       "\n",
       "<li>value: 1.0</li>\n",
       "\n",
       "<li>desc: Normalization (differential flux at the pivot value)</li>\n",
       "\n",
       "<li>min_value: 1e-30</li>\n",
       "\n",
       "<li>max_value: 1000.0</li>\n",
       "\n",
       "<li>unit: keV-1 s-1 cm-2</li>\n",
       "\n",
       "<li>is_normalization: True</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>piv: \n",
       "<ul>\n",
       "\n",
       "<li>value: 1.0</li>\n",
       "\n",
       "<li>desc: Pivot value</li>\n",
       "\n",
       "<li>min_value: None</li>\n",
       "\n",
       "<li>max_value: None</li>\n",
       "\n",
       "<li>unit: keV</li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.1</li>\n",
       "\n",
       "<li>free: False</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "<li>index: \n",
       "<ul>\n",
       "\n",
       "<li>value: -2.01</li>\n",
       "\n",
       "<li>desc: Photon index</li>\n",
       "\n",
       "<li>min_value: -10.0</li>\n",
       "\n",
       "<li>max_value: 10.0</li>\n",
       "\n",
       "<li>unit: </li>\n",
       "\n",
       "<li>is_normalization: False</li>\n",
       "\n",
       "<li>delta: 0.20099999999999998</li>\n",
       "\n",
       "<li>free: True</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n",
       "\n",
       "</li>\n",
       "\n",
       "</ul>\n"
      ],
      "text/plain": [
       "  * description: A simple power-law\n",
       "  * formula: $ K~\\frac{x}{piv}^{index} $\n",
       "  * parameters:\n",
       "    * K:\n",
       "      * value: 1.0\n",
       "      * desc: Normalization (differential flux at the pivot value)\n",
       "      * min_value: 1.0e-30\n",
       "      * max_value: 1000.0\n",
       "      * unit: keV-1 s-1 cm-2\n",
       "      * is_normalization: true\n",
       "      * delta: 0.1\n",
       "      * free: true\n",
       "    * piv:\n",
       "      * value: 1.0\n",
       "      * desc: Pivot value\n",
       "      * min_value: null\n",
       "      * max_value: null\n",
       "      * unit: keV\n",
       "      * is_normalization: false\n",
       "      * delta: 0.1\n",
       "      * free: false\n",
       "    * index:\n",
       "      * value: -2.01\n",
       "      * desc: Photon index\n",
       "      * min_value: -10.0\n",
       "      * max_value: 10.0\n",
       "      * unit: ''\n",
       "      * is_normalization: false\n",
       "      * delta: 0.20099999999999998\n",
       "      * free: true"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "powerlaw_instance.display()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "a1fa46d4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.101474Z",
     "iopub.status.busy": "2024-02-07T19:30:31.101078Z",
     "iopub.status.idle": "2024-02-07T19:30:31.112395Z",
     "shell.execute_reply": "2024-02-07T19:30:31.110494Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\mathrm{keV}$"
      ],
      "text/plain": [
       "Unit(\"keV\")"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "powerlaw_instance.x_unit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "61af02b3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.121299Z",
     "iopub.status.busy": "2024-02-07T19:30:31.120605Z",
     "iopub.status.idle": "2024-02-07T19:30:31.132059Z",
     "shell.execute_reply": "2024-02-07T19:30:31.130208Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\mathrm{\\frac{1}{keV\\,s\\,cm^{2}}}$"
      ],
      "text/plain": [
       "Unit(\"1 / (keV s cm2)\")"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "powerlaw_instance.y_unit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "d144ba35",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.141959Z",
     "iopub.status.busy": "2024-02-07T19:30:31.141236Z",
     "iopub.status.idle": "2024-02-07T19:30:31.155608Z",
     "shell.execute_reply": "2024-02-07T19:30:31.152808Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Parameter K = 0.1223 [1 / (keV s cm2)]\n",
      "(min_value = 1e-30, max_value = 1000.0, delta = 0.1, free = True)\n",
      "Parameter K = 1.2230000000000013e-08 [1 / (keV s cm2)]\n",
      "(min_value = 1e-30, max_value = 1000.0, delta = 0.1, free = True)\n"
     ]
    }
   ],
   "source": [
    "import astropy.units as u\n",
    "\n",
    "# Express the differential flux at the pivot energy in 1 / (MeV cm2 s)\n",
    "\n",
    "powerlaw_instance.K = (122.3 / (u.MeV * u.cm * u.cm * u.s))\n",
    "\n",
    "print(powerlaw_instance.K)\n",
    "\n",
    "# Express the differential flux at the pivot energy in 1 / (GeV m2 s)\n",
    "powerlaw_instance.K = (122.3 / (u.GeV * u.m * u.m * u.s))\n",
    "\n",
    "\n",
    "print(powerlaw_instance.K)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "25779b3f",
   "metadata": {},
   "source": [
    "We see that astromodels does the unit conversion for us in the background!\n",
    "\n",
    "However, astropy units are **very slow** and we would not want to deal with them or set parameters with units during a fit. Thus, if you do not specify units when setting a parameter, the value is assumed to have the units specified in the construction of the function. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "30826935",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:31.165864Z",
     "iopub.status.busy": "2024-02-07T19:30:31.165076Z",
     "iopub.status.idle": "2024-02-07T19:30:48.772241Z",
     "shell.execute_reply": "2024-02-07T19:30:48.769860Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "21.8 µs ± 5.09 µs per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit powerlaw_instance.K = 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "fcc8b07a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:48.783761Z",
     "iopub.status.busy": "2024-02-07T19:30:48.783106Z",
     "iopub.status.idle": "2024-02-07T19:30:53.079145Z",
     "shell.execute_reply": "2024-02-07T19:30:53.075376Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "538 µs ± 244 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n"
     ]
    }
   ],
   "source": [
    "%timeit powerlaw_instance.K = (122.3 / (u.MeV * u.cm * u.cm * u.s))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c9034f1",
   "metadata": {},
   "source": [
    "As you can see using **astropy.units requires about 10x more than using a plain assignment**. In an interactive analysis you are unlikely to notice the difference, but if you use units in a loop or during a fit this slow-down will add up an become very noticeable. **Note that this is a feature of astropy.units, not of astromodels.**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8fe86db3",
   "metadata": {},
   "source": [
    "## Composing functions\n",
    "\n",
    "We can create arbitrary complex functions by combining “primitive” functions using the normal math operators:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "f0872d89",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.091405Z",
     "iopub.status.busy": "2024-02-07T19:30:53.090966Z",
     "iopub.status.idle": "2024-02-07T19:30:53.182271Z",
     "shell.execute_reply": "2024-02-07T19:30:53.171380Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(Gaussian{1} + Powerlaw{2})\n"
     ]
    }
   ],
   "source": [
    "composite = Gaussian() + Powerlaw()\n",
    "\n",
    "# Instead of the usual .display(), which would print all the many parameters,\n",
    "# let's print just the description of the new composite functions:\n",
    "print(composite.description)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a38e7576",
   "metadata": {},
   "source": [
    "These expressions can be as complex as needed. For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "f0b44fd1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.227827Z",
     "iopub.status.busy": "2024-02-07T19:30:53.225322Z",
     "iopub.status.idle": "2024-02-07T19:30:53.304624Z",
     "shell.execute_reply": "2024-02-07T19:30:53.301448Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "((Sin{1} * 3) + (((Powerlaw{2} ** 2) * (Gaussian{3} + 5)) / 3.0))\n"
     ]
    }
   ],
   "source": [
    "crazy_function = 3 * Sin() + Powerlaw()**2 * (5+Gaussian()) / 3.0\n",
    "\n",
    "print(crazy_function.description)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "909bd617",
   "metadata": {},
   "source": [
    "The numbers between ```{}``` enumerate the unique functions which constitute a composite function. This is useful because composite functions can be created starting from pre-existing instances of functions, in which case the same instance can be used more than once. For example:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "8953f493",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.316276Z",
     "iopub.status.busy": "2024-02-07T19:30:53.315724Z",
     "iopub.status.idle": "2024-02-07T19:30:53.330784Z",
     "shell.execute_reply": "2024-02-07T19:30:53.328541Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "((Powerlaw{1} * 2) + ((Powerlaw{1} + 3) * Sin{2}))\n"
     ]
    }
   ],
   "source": [
    "a_powerlaw = Powerlaw()\n",
    "a_sin = Sin()\n",
    "\n",
    "another_composite = 2 * a_powerlaw + (3 + a_powerlaw) * a_sin\n",
    "\n",
    "print(another_composite.description)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "289502d0",
   "metadata": {},
   "source": [
    "In this case the same instance of a power law has been used twice. Changing the value of the parameters for “a_powerlaw” will affect also the second part of the expression. Instead, by doing this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "bc36b431",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.338724Z",
     "iopub.status.busy": "2024-02-07T19:30:53.338316Z",
     "iopub.status.idle": "2024-02-07T19:30:53.350524Z",
     "shell.execute_reply": "2024-02-07T19:30:53.348338Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "((Powerlaw{1} * 2) + ((Powerlaw{2} + 3) * Sin{3}))\n"
     ]
    }
   ],
   "source": [
    "another_composite2 = 2 * Powerlaw() + (3 + Powerlaw()) * Sin()\n",
    "\n",
    "print(another_composite2.description)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cb6dcbf6",
   "metadata": {},
   "source": [
    "we will end up with two independent sets of parameters for the two power laws. The difference can be seen immediately from the number of parameters of the two composite functions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "c76c3957",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.370493Z",
     "iopub.status.busy": "2024-02-07T19:30:53.369959Z",
     "iopub.status.idle": "2024-02-07T19:30:53.383337Z",
     "shell.execute_reply": "2024-02-07T19:30:53.378365Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "6\n",
      "9\n"
     ]
    }
   ],
   "source": [
    "print(len(another_composite.parameters)) # 6 parameters\n",
    "print(len(another_composite2.parameters)) # 9 parameters"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7be97f61",
   "metadata": {},
   "source": [
    "## Creating custom functions\n",
    "\n",
    "One of the most powerful aspects of astromodels is the ability to quickly build custom functions on the fly. The source code for a function can be pure python, FORTRAN linked via f2py, C++ linked via cython, etc. Anything that provides a python function can be used to fit data. \n",
    "\n",
    "To build a custom spectral 1D function in astromodels, we need to import a few things that will allow astromodels to recognize your model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "1f11c14a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.402947Z",
     "iopub.status.busy": "2024-02-07T19:30:53.402528Z",
     "iopub.status.idle": "2024-02-07T19:30:53.413454Z",
     "shell.execute_reply": "2024-02-07T19:30:53.409375Z"
    }
   },
   "outputs": [],
   "source": [
    "from astromodels.functions.function import Function1D, FunctionMeta, ModelAssertionViolation"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8a080ce9",
   "metadata": {},
   "source": [
    "```Function1D``` is the base class for 1D spectral models and ```FunctionMeta``` is a python meta type class that ensures all the needed parts of a model are in the class as well as making the class function as it should.\n",
    "\n",
    "\n",
    "There are three basic parts to declaring a model:\n",
    "\n",
    "* the docstring\n",
    "* the units setter\n",
    "* the evaluate function\n",
    "\n",
    "Let's look at the simple case of the power law already define in astromodels.\n",
    "\n",
    "\n",
    "```python\n",
    "class Powerlaw(Function1D, metaclass=FunctionMeta):\n",
    "        r\"\"\"\n",
    "        description :\n",
    "            A  power-law\n",
    "        latex : $ K~\\frac{x}{piv}^{index} $\n",
    "        parameters :\n",
    "            K :\n",
    "                desc : Normalization (differential flux at the pivot value)\n",
    "                initial value : 1.0\n",
    "                is_normalization : True\n",
    "                transformation : log10\n",
    "                min : 1e-30\n",
    "                max : 1e3\n",
    "                delta : 0.1\n",
    "            piv :\n",
    "                desc : Pivot value\n",
    "                initial value : 1\n",
    "                fix : yes\n",
    "            index :\n",
    "                desc : Photon index\n",
    "                initial value : -2\n",
    "                min : -10\n",
    "                max : 10\n",
    "        \"\"\"\n",
    "\n",
    "\n",
    "        def _set_units(self, x_unit, y_unit):\n",
    "            # The index is always dimensionless\n",
    "            self.index.unit = astropy_units.dimensionless_unscaled\n",
    "\n",
    "            # The pivot energy has always the same dimension as the x variable\n",
    "            self.piv.unit = x_unit\n",
    "\n",
    "            # The normalization has the same units as the y\n",
    "\n",
    "            self.K.unit = y_unit\n",
    "\n",
    "\n",
    "        def evaluate(self, x, K, piv, index):\n",
    "\n",
    "            xx = np.divide(x, piv)\n",
    "\n",
    "            return K * np.power(xx, index)\n",
    "\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f8de5a2",
   "metadata": {},
   "source": [
    "### The docstring\n",
    "\n",
    "We have used the docstring interface to provide a YAML description of the function. This sets up the important information used in the fitting process and record keeping. The docstring has three parts:\n",
    "\n",
    "- description\n",
    "    - The description is a text string that provides readable info about the model. Nothing fancy, but good descriptions help to inform the user.\n",
    "- latex\n",
    "    - If the model is analytic, a latex formula can be included\n",
    "- parameters\n",
    "    - For each parameter, a description and initial value must be included. Transformations for fitting, min/max values and fixing the parameter can also be described here.\n",
    "\n",
    "Optionally, there can be an additional ```properties``` category that we will cover later.\n",
    "\n",
    "    \n",
    "Keep in mind that this is in YAML format.\n",
    "\n",
    "### Set units\n",
    "\n",
    "astromodels keeps track of units for you. However, a model must be set up to properly describe the units with astropy's unit system. Keep in mind that models are fit with a differential photon flux, \n",
    "\n",
    "$$\\frac{d N_p}{dA dt dE}$$\n",
    "\n",
    "so your units should reflect this convention. Therefore, proper normalizations should be taken into account.\n",
    "\n",
    "\n",
    "### Evaluate\n",
    "This is where the function is evaluated. The first argument **must be called x** and the parameter names and ordering must reflect what is in the docstring. Any number of operations can take place inside the evaluate call, but remember that the return must be in the form of a differential photon flux. For 2D and 3D functions, the functions have **y** and **z** for their first arguments as well. ** x, y, and z  are reserved names in functions**. \n",
    "\n",
    "\n",
    "A functions is defined in a python session. **If you save the results of a fit to an AnalysisResults file and try to load this file without loading this model, you will get a error** Thus, remember to import any local models you used for an analysis before trying to reload that analysis. \n",
    "\n",
    "\n",
    "## Custom functions in other langauges\n",
    "\n",
    "What if your model is built from a C++ function and you want to fit that directly to the data? using Cython, pybind11, f2py, etc, you can wrap these models and call them easily."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "1c147612",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.428508Z",
     "iopub.status.busy": "2024-02-07T19:30:53.427761Z",
     "iopub.status.idle": "2024-02-07T19:30:53.439251Z",
     "shell.execute_reply": "2024-02-07T19:30:53.434578Z"
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "def cpp_function_wrapper(a):\n",
    "    # we could wrap a c++ function here\n",
    "    # with cython, pybind11, etc\n",
    "    \n",
    "    return a\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "a6a23afa",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.459811Z",
     "iopub.status.busy": "2024-02-07T19:30:53.459252Z",
     "iopub.status.idle": "2024-02-07T19:30:53.501950Z",
     "shell.execute_reply": "2024-02-07T19:30:53.491144Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.0"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_function_wrapper(2.)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7e59585",
   "metadata": {},
   "source": [
    "Now we will define a astromodels function that will handle both the unit and non-unit call."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "3ec71385",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.618214Z",
     "iopub.status.busy": "2024-02-07T19:30:53.613420Z",
     "iopub.status.idle": "2024-02-07T19:30:53.757457Z",
     "shell.execute_reply": "2024-02-07T19:30:53.753961Z"
    }
   },
   "outputs": [],
   "source": [
    "import astropy.units as astropy_units\n",
    "\n",
    "class CppModel(Function1D,metaclass=FunctionMeta):\n",
    "        r\"\"\"\n",
    "        description :\n",
    "            A spectral model wrapping a cython function\n",
    "        latex : $$\n",
    "        parameters :\n",
    "            a :\n",
    "                desc : Normalization (differential flux)\n",
    "                initial value : 1.0\n",
    "                is_normalization : True\n",
    "                min : 1e-30\n",
    "                max : 1e3\n",
    "                delta : 0.1\n",
    "        \"\"\"\n",
    "\n",
    "        def _set_units(self, x_unit, y_unit):\n",
    "\n",
    "            # The normalization has the same units as the y\n",
    "\n",
    "            self.a.unit = y_unit\n",
    "\n",
    "        \n",
    "        def evaluate(self, x, a):\n",
    "            \n",
    "            # check is the function is being called with units\n",
    "            \n",
    "            if isinstance(a, astropy_units.Quantity):\n",
    "                \n",
    "                # get the values\n",
    "                a_ = a.value\n",
    "                \n",
    "                # save the unit\n",
    "                unit_ = self.y_unit\n",
    "                \n",
    "            else:\n",
    "                \n",
    "                # we do not need to do anything here\n",
    "                a_ = a\n",
    "                \n",
    "                # this will basically be ignored\n",
    "                unit_ = 1.\n",
    "\n",
    "            # call the cython function\n",
    "            flux = cpp_function_wrapper(a_)\n",
    "\n",
    "            # add back the unit if needed\n",
    "            return flux * unit_"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "00b1df4d",
   "metadata": {},
   "source": [
    "We can check the unit and non-unit call by making a point source and evaluating it"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "6995d33b",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:53.769775Z",
     "iopub.status.busy": "2024-02-07T19:30:53.769095Z",
     "iopub.status.idle": "2024-02-07T19:30:55.217637Z",
     "shell.execute_reply": "2024-02-07T19:30:55.216082Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1.0\n"
     ]
    },
    {
     "data": {
      "text/latex": [
       "$1 \\; \\mathrm{\\frac{1}{keV\\,s\\,cm^{2}}}$"
      ],
      "text/plain": [
       "<Quantity 1. 1 / (keV s cm2)>"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cpp_spectrum = CppModel()\n",
    "\n",
    "from astromodels import PointSource\n",
    "\n",
    "point_source = PointSource('ps',0,0,spectral_shape=cpp_spectrum)\n",
    "\n",
    "print(point_source(10.))\n",
    "point_source(10. * astropy_units.keV)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9f6406a1",
   "metadata": {},
   "source": [
    "## Advanced functions\n",
    "\n",
    "We are not limited to functions that can only take numerical parameters as arguments. We can also link other astromodels function into a function to expand its abilities. \n",
    "### Properties\n",
    "\n",
    "Let's create a function that uses text based switches to alter its functionality\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "0d4372b9",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:55.225364Z",
     "iopub.status.busy": "2024-02-07T19:30:55.224470Z",
     "iopub.status.idle": "2024-02-07T19:30:55.240152Z",
     "shell.execute_reply": "2024-02-07T19:30:55.238642Z"
    }
   },
   "outputs": [],
   "source": [
    "class SwitchFunction(Function1D,metaclass=FunctionMeta):\n",
    "        r\"\"\"\n",
    "        description :\n",
    "            A demo function that can alter its state\n",
    "        latex : $$\n",
    "        \n",
    "        parameters :\n",
    "            a :\n",
    "                desc : Normalization (differential flux)\n",
    "                initial value : 1.0\n",
    "                is_normalization : True\n",
    "                min : 1e-30\n",
    "                max : 1e3\n",
    "                delta : 0.1\n",
    "        properties:\n",
    "            switch:\n",
    "                desc: a switch for functions\n",
    "                initial value: powerlaw\n",
    "                allowed values:\n",
    "                    - powerlaw\n",
    "                    - cosine\n",
    "                function: _say_hello\n",
    "        \"\"\"\n",
    "        def _say_hello(self):\n",
    "        # called when we set the value of switch\n",
    "\n",
    "            print(self.switch.value)\n",
    "\n",
    "\n",
    "        def _set_units(self, x_unit, y_unit):\n",
    "\n",
    "            # The normalization has the same units as the y\n",
    "\n",
    "            self.a.unit = y_unit\n",
    "\n",
    "        \n",
    "        def evaluate(self, x, a):\n",
    "\n",
    "            if self.switch.value == \"powerlaw\":\n",
    "\n",
    "                return a * np.powerlaw(x,-2)\n",
    "\n",
    "            elif self.switch.value == \"cosine\":\n",
    "                \n",
    "                return a * np.cos(x)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c4ab9c01",
   "metadata": {},
   "source": [
    "We have added a text parameter called switch and specified the allowed values that it can take on. We can of course allow it to take on any value. Additionally, we have specified a function to call whenever we change the value. This allows use to do things like read in a table from a dictionary or load a file, etc. Properties can be set in the constructor of a function. They behave just like parameters except that they do not participate in the function call. Thus, their state is saved whenever you serialize the model to disk. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "493148fe",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:55.247586Z",
     "iopub.status.busy": "2024-02-07T19:30:55.247119Z",
     "iopub.status.idle": "2024-02-07T19:30:55.257408Z",
     "shell.execute_reply": "2024-02-07T19:30:55.255907Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "powerlaw\n",
      "cosine\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "f = SwitchFunction()\n",
    "\n",
    "f.switch = 'cosine'\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "28eb7ae9",
   "metadata": {},
   "source": [
    "In the docstring, one can also specify ```defer: True``` which allows you to not set a value until instancing an object. This is useful if you have a model that reads in file at runtime, but the file name is not known until then. Check out the source code of astromodels to see how properties can be used to expand the functionality of your custom models. For example, the absorption models such as ```TbAbs``` take advantage of this to set their abundance tables.\n",
    "\n",
    "### Linking functions\n",
    "\n",
    "What if you need to call another astromodels function from inside your custom function? This is achieved by linking functions. For example, let's create a convolutional model that redshifts the energies of and model linked to it:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "4584839d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:55.265044Z",
     "iopub.status.busy": "2024-02-07T19:30:55.264643Z",
     "iopub.status.idle": "2024-02-07T19:30:55.276343Z",
     "shell.execute_reply": "2024-02-07T19:30:55.274530Z"
    }
   },
   "outputs": [],
   "source": [
    "class Redshifter(Function1D, metaclass=FunctionMeta):\n",
    "    r\"\"\"\n",
    "    description :\n",
    "        a function that can redshift the energies of any 1D function\n",
    "\n",
    "    latex: not available\n",
    "\n",
    "    parameters :\n",
    "        redshift :\n",
    "            desc : the redshift\n",
    "            initial value : 0\n",
    "            min : 0\n",
    "\n",
    "    \"\"\"\n",
    "\n",
    "    \n",
    "    def _set_units(self, x_unit, y_unit):\n",
    "\n",
    "        self.redshift.unit = astropy_units.dimensionless_unscaled \n",
    "\n",
    "\n",
    "    def set_linked_function(self, function):\n",
    "\t     # this is an optional helper to\n",
    "\t\t # ease in the setting of the function\n",
    "\n",
    "\t\n",
    "\n",
    "        if \"func\" in self._external_functions:\n",
    "   \n",
    "            # since we only want to link one function\n",
    "\t\t\t# we unlink if we have linked before \n",
    "\t\t\t\n",
    "            self.unlink_external_function(\"func\")\n",
    " \n",
    "        # this allows use to link in a function \n",
    "\t\t# with an internal name 'func'\n",
    "\t\t\n",
    "        self.link_external_function(function, \"func\")\n",
    "        \n",
    "        self._linked_function = function\n",
    "\n",
    "    def get_linked_function(self):\n",
    "\n",
    "\t    # linked functions are stored in a dictionary\n",
    "\t\t# but you \n",
    "\n",
    "        return self._external_functions[\"func\"]\n",
    "        \n",
    "\n",
    "    linked_function = property(\n",
    "        get_linked_function,\n",
    "        set_linked_function,\n",
    "        doc=\"\"\"Get/set linked function\"\"\",\n",
    "    )\n",
    "\n",
    "\n",
    "    def evaluate(self, x, redshift):\n",
    "\n",
    "\n",
    "        # we can call the function here\n",
    "        return self._linked_function(x * (1 + redshift))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a821570f",
   "metadata": {},
   "source": [
    "With this function, whenever we set the linked_function property to another astromodels function, its call will return that function redshifted."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "b062bb85",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2024-02-07T19:30:55.283991Z",
     "iopub.status.busy": "2024-02-07T19:30:55.283546Z",
     "iopub.status.idle": "2024-02-07T19:30:55.874346Z",
     "shell.execute_reply": "2024-02-07T19:30:55.870830Z"
    },
    "lines_to_next_cell": 2
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.009772372209558112\n",
      "0.0024262173759824015\n"
     ]
    }
   ],
   "source": [
    "p = Powerlaw()\n",
    "rs = Redshifter(redshift=1)\n",
    "\n",
    "rs.linked_function = p\n",
    "\n",
    "print(p(10.))\n",
    "\n",
    "print(rs(10.))\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ca94870",
   "metadata": {},
   "source": [
    "We have added a lot of syntax sugar to make it easier for users to handle the function, but every function in astromodels has the members ```f.link_external_function(func, 'internal_name')```  and ```f.unlink_external_function('internal_name')```. You can link as many functions as needed and they are accessed via an internal dictionary ```self._extranal_functions```. As long as all functions used are part of the model, all the linking is saved when a model is saved to disk allowing you to restore all the complexity you built. "
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,md"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
